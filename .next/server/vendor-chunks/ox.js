"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/./node_modules/ox/_esm/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/* v8 ignore next */\nassert.parseError = (error) => error;\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/* v8 ignore next */\nconcat.parseError = (error) => error;\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\nfrom.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\nfromArray.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\nfromBoolean.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    if (value.length % 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_1__.InvalidLengthError(value);\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_2__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.padRight(value, size);\n    }\n    const hexString = hex.slice(2);\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/* v8 ignore next */\nfromHex.parseError = (error) => error;\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(value, options);\n    return fromHex(hex);\n}\nfromNumber.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\nfromString.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/* v8 ignore next */\nisEqual.parseError = (error) => error;\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/* v8 ignore next */\npadLeft.parseError = (error) => error;\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/* v8 ignore next */\npadRight.parseError = (error) => error;\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/* v8 ignore next */\nrandom.parseError = (error) => error;\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/* v8 ignore next */\nsize.parseError = (error) => error;\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/* v8 ignore next */\nslice.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toBigInt(hex, options);\n}\ntoBigInt.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\ntoBoolean.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(value, options);\n}\n/* v8 ignore next */\ntoHex.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.toNumber(hex, options);\n}\ntoNumber.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\ntoString.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/* v8 ignore next */\ntrimLeft.parseError = (error) => error;\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/* v8 ignore next */\ntrimRight.parseError = (error) => error;\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/* v8 ignore next */\nvalidate.parseError = (error) => error;\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNwQjtBQUNOO0FBQ0U7QUFDYztBQUNFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNP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QTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDBDQUEwQyxpREFBZ0I7QUFDakUsa0JBQWtCLHlCQUF5QjtBQUMzQyx1QkFBdUIsOENBQThDLGNBQWMsT0FBTywrQkFBK0IsS0FBSztBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcQnl0ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXF1YWxCeXRlcyB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvdXRpbHMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsX2hleCBmcm9tICcuL2ludGVybmFsL2hleC5qcyc7XG5jb25zdCBkZWNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5hc3NlcnQoJ2FiYycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjpcbiAqIC8vIEBlcnJvcjogVmFsdWUgYFwiYWJjXCJgIG9mIHR5cGUgYHN0cmluZ2AgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgVWludDhBcnJheWAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICghKCdCWVRFU19QRVJfRUxFTUVOVCcgaW4gdmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodmFsdWUuQllURVNfUEVSX0VMRU1FTlQgIT09IDEgfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSAhPT0gJ1VpbnQ4QXJyYXknKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5hc3NlcnQucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5jb25jYXQucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgZnJvbSBhIGBVaW50OEFycmF5YCwgYSBoZXggc3RyaW5nLCBvciBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2Vycy5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBCeXRlcy5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBCeXRlcy5mcm9tU3RyaW5nYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb20oWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyMjIsIDE3MywgMTkwLCAyMzldKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbn1cbmZyb20ucGFyc2VFcnJvciA9IChlcnJvcikgPT4gXG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZXJyb3I7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21BcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbn1cbmZyb21BcnJheS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogRW5jb2RlcyBhIGJvb2xlYW4gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzFdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQm9vbGVhbih0cnVlLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEJvb2xlYW4gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJvb2xlYW4odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGJ5dGVzWzBdID0gTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkTGVmdChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZyb21Cb29sZWFuLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IFxuLyogdjggaWdub3JlIG5leHQgKi9cbmVycm9yO1xuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21IZXgoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21IZXgoJzB4NDg2NTZjNmM2ZjIwNzc2ZjcyNmM2NDIxJywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBIZXguSW52YWxpZExlbmd0aEVycm9yKHZhbHVlKTtcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBjb25zdCBoZXhTdHJpbmcgPSBoZXguc2xpY2UoMik7XG4gICAgY29uc3QgbGVuZ3RoID0gaGV4U3RyaW5nLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMCwgaiA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IG5pYmJsZUxlZnQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBjb25zdCBuaWJibGVSaWdodCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGlmIChuaWJibGVMZWZ0ID09PSB1bmRlZmluZWQgfHwgbmliYmxlUmlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoYEludmFsaWQgYnl0ZSBzZXF1ZW5jZSAoXCIke2hleFN0cmluZ1tqIC0gMl19JHtoZXhTdHJpbmdbaiAtIDFdfVwiIGluIFwiJHtoZXhTdHJpbmd9XCIpLmApO1xuICAgICAgICB9XG4gICAgICAgIGJ5dGVzW2luZGV4XSA9IG5pYmJsZUxlZnQgKiAxNiArIG5pYmJsZVJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZnJvbUhleC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciB2YWx1ZSBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDE2NF0pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwLCB7IHNpemU6IDQgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDEsIDE2NF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBOdW1iZXIgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZnJvbUhleChoZXgpO1xufVxuZnJvbU51bWJlci5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIHdvcmxkIScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzMywgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBTdHJpbmcgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBFbmNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRW5jb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChieXRlcywgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZyb21TdHJpbmcucGFyc2VFcnJvciA9IChlcnJvcikgPT4gXG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZXJyb3I7XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsyXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzQSAtIEZpcnN0IHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gYnl0ZXNCIC0gU2Vjb25kIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIGVxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhieXRlc0EsIGJ5dGVzQik7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuaXNFcXVhbC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gdGhlIGxlZnQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRMZWZ0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDFdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRMZWZ0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdsZWZ0Jywgc2l6ZSB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5wYWRMZWZ0LnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byB0aGUgcmlnaHQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5wYWRSaWdodChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAwLCAwLCAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5wYWRSaWdodC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogR2VuZXJhdGVzIHJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLnJhbmRvbSgzMilcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWy4uLiB4MzJdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIGxlbmd0aCAtIExlbmd0aCBvZiB0aGUgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZ2VuZXJhdGUuXG4gKiBAcmV0dXJucyBSYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW5ndGgpKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5yYW5kb20ucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc2l6ZSBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNpemUoQnl0ZXMuZnJvbShbMSwgMiwgMywgNF0pKVxuICogLy8gQGxvZzogNFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFNpemUgb2YgdGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5zaXplLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBSZXR1cm5zIGEgc2VjdGlvbiBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgZ2l2ZW4gYSBzdGFydC9lbmQgYnl0ZXMgb2Zmc2V0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zbGljZShcbiAqICAgQnl0ZXMuZnJvbShbMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV0pLFxuICogICAxLFxuICogICA0LFxuICogKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMiwgMywgNF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEBwYXJhbSBzdGFydCAtIFN0YXJ0IG9mZnNldC5cbiAqIEBwYXJhbSBlbmQgLSBFbmQgb2Zmc2V0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBTbGljZSBvcHRpb25zLlxuICogQHJldHVybnMgU2xpY2VkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZSh2YWx1ZSwgc3RhcnQsIGVuZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgfSA9IG9wdGlvbnM7XG4gICAgaW50ZXJuYWwuYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KTtcbiAgICBjb25zdCB2YWx1ZV8gPSB2YWx1ZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICBpZiAoc3RyaWN0KVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRFbmRPZmZzZXQodmFsdWVfLCBzdGFydCwgZW5kKTtcbiAgICByZXR1cm4gdmFsdWVfO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnNsaWNlLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgYmlnaW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50b0JpZ0ludChCeXRlcy5mcm9tKFsxLCAxNjRdKSlcbiAqIC8vIEBsb2c6IDQyMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRGVjb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgYmlnaW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvQmlnSW50KGhleCwgb3B0aW9ucyk7XG59XG50b0JpZ0ludC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbnRvQm9vbGVhbi5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9IZXgoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xudG9IZXgucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b051bWJlcihoZXgsIG9wdGlvbnMpO1xufVxudG9OdW1iZXIucGFyc2VFcnJvciA9IChlcnJvcikgPT4gXG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZXJyb3I7XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBzdHJpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy50b1N0cmluZyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBieXRlcyAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIERlY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9TdHJpbmcoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1SaWdodChieXRlc18pO1xuICAgIH1cbiAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoYnl0ZXNfKTtcbn1cbnRvU3RyaW5nLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IFxuLyogdjggaWdub3JlIG5leHQgKi9cbmVycm9yO1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltTGVmdChCeXRlcy5mcm9tKFswLCAwLCAwLCAwLCAxLCAyLCAzXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxLCAyLCAzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBUcmltbWVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltTGVmdCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ2xlZnQnIH0pO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnRyaW1MZWZ0LnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBUcmltcyB0cmFpbGluZyB6ZXJvcyBmcm9tIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudHJpbVJpZ2h0KEJ5dGVzLmZyb20oWzEsIDIsIDMsIDAsIDAsIDAsIDBdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50cmltUmlnaHQucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogQnl0ZXMudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogdHJ1ZVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG90aGVyd2lzZSBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQodmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnZhbGlkYXRlLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgYnl0ZXMgdmFsdWUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9Cb29sZWFuKEJ5dGVzLmZyb20oWzVdKSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yOiBCeXRlcyB2YWx1ZSBgWzVdYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoYEJ5dGVzIHZhbHVlIFxcYCR7Ynl0ZXN9XFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBieXRlcyBhcnJheSBtdXN0IGNvbnRhaW4gYSBzaW5nbGUgYnl0ZSBvZiBlaXRoZXIgYSBgMGAgb3IgYDFgIHZhbHVlLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHZhbHVlIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYnl0ZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbSgnZm9vJylcbiAqIC8vIEBlcnJvcjogQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yOiBWYWx1ZSBgZm9vYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc1R5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBCeXRlcyB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnQnl0ZXMgdmFsdWVzIG11c3QgYmUgb2YgdHlwZSBgQnl0ZXNgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb21TdHJpbmcoJ0hlbGxvIFdvcmxkIScsIHsgc2l6ZTogOCB9KVxuICogLy8gQGVycm9yOiBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzbGljZSBvZmZzZXQgaXMgb3V0LW9mLWJvdW5kcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuc2xpY2UoQnl0ZXMuZnJvbShbMSwgMiwgM10pLCA0KVxuICogLy8gQGVycm9yOiBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3I6IFNsaWNlIHN0YXJ0aW5nIGF0IG9mZnNldCBgNGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogYDNgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQsIHBvc2l0aW9uLCBzaXplLCB9KSB7XG4gICAgICAgIHN1cGVyKGBTbGljZSAke3Bvc2l0aW9uID09PSAnc3RhcnQnID8gJ3N0YXJ0aW5nJyA6ICdlbmRpbmcnfSBhdCBvZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IFxcYCR7c2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgdGhlIHBhZGRpbmcgc2l6ZSBleGNlZWRzIHRoZSBtYXhpbXVtIGFsbG93ZWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnKSwgOClcbiAqIC8vIEBlcnJvcjogW0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogQnl0ZXMgc2l6ZSAoYDEyYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGA4YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CeXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Ens.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Ens.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   labelhash: () => (/* binding */ labelhash),\n/* harmony export */   namehash: () => (/* binding */ namehash),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/./node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/ens.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/ens.js\");\n\n\n\n\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nfunction labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    return (_internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(label) || _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(label)));\n}\nlabelhash.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nfunction namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    const labels = name.split('.');\n    // Iterate in reverse order building up hash\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n        const hashFromEncodedLabel = _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(hashFromEncodedLabel)\n            : _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(labels[i]), { as: 'Bytes' });\n        result = _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(result, hashed), { as: 'Bytes' });\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n}\nnamehash.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nfunction normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n}\nnormalize.parseError = (error) => \n/* v8 ignore next */\nerror;\n//# sourceMappingURL=Ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1RDtBQUNuQjtBQUNGO0FBQ0Y7QUFDYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxzV0FBc1csbUNBQW1DO0FBQ3pZO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsOENBQWE7QUFDNUIsWUFBWSw2REFBd0IsV0FBVywrQ0FBYyxDQUFDLCtDQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVdBQW1XLG1DQUFtQztBQUN0WTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QyxxQ0FBcUMsNkRBQXdCO0FBQzdEO0FBQ0EsY0FBYyw4Q0FBYTtBQUMzQixjQUFjLCtDQUFjLENBQUMsaURBQWdCLGVBQWUsYUFBYTtBQUN6RSxpQkFBaUIsK0NBQWMsQ0FBQyw2Q0FBWSxvQkFBb0IsYUFBYTtBQUM3RTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxRUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFBDXFxEb2N1bWVudHNcXERBT1xcQXBwXFxjb21tYXBwXFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxFbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5zX25vcm1hbGl6ZSB9IGZyb20gJ0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9lbnMuanMnO1xuLyoqXG4gKiBIYXNoZXMgRU5TIGxhYmVsLlxuICpcbiAqIFNpbmNlIEVOUyBsYWJlbHMgcHJvaGliaXQgY2VydGFpbiBmb3JiaWRkZW4gY2hhcmFjdGVycyAoZS5nLiB1bmRlcnNjb3JlKSBhbmQgaGF2ZSBvdGhlciB2YWxpZGF0aW9uIHJ1bGVzLCB5b3UgbGlrZWx5IHdhbnQgdG8gW25vcm1hbGl6ZSBFTlMgbGFiZWxzXShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvY29udHJhY3QtYXBpLXJlZmVyZW5jZS9uYW1lLXByb2Nlc3Npbmcjbm9ybWFsaXNpbmctbmFtZXMpIHdpdGggW1VUUy00NiBub3JtYWxpemF0aW9uXShodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHI0NikgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBgbGFiZWxoYXNoYC4gWW91IGNhbiB1c2UgdGhlIGJ1aWx0LWluIHtAbGluayBveCNFbnMuKG5vcm1hbGl6ZTpmdW5jdGlvbil9IGZ1bmN0aW9uIGZvciB0aGlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKiBFbnMubGFiZWxoYXNoKCdldGgnKVxuICogJzB4NGY1YjgxMjc4OWZjNjA2YmUxYjNiMTY5MDhkYjEzZmM3YTlhZGY3Y2E3MjY0MWY4NGQ3NWI0NzA2OWQzZDdmMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBsYWJlbCAtIEVOUyBsYWJlbC5cbiAqIEByZXR1cm5zIEVOUyBsYWJlbGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsYWJlbGhhc2gobGFiZWwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICBpZiAoIWxhYmVsKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xuICAgIHJldHVybiAoaW50ZXJuYWwudW53cmFwTGFiZWxoYXNoKGxhYmVsKSB8fCBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhsYWJlbCkpKTtcbn1cbmxhYmVsaGFzaC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogSGFzaGVzIEVOUyBuYW1lLlxuICpcbiAqIFNpbmNlIEVOUyBuYW1lcyBwcm9oaWJpdCBjZXJ0YWluIGZvcmJpZGRlbiBjaGFyYWN0ZXJzIChlLmcuIHVuZGVyc2NvcmUpIGFuZCBoYXZlIG90aGVyIHZhbGlkYXRpb24gcnVsZXMsIHlvdSBsaWtlbHkgd2FudCB0byBbbm9ybWFsaXplIEVOUyBuYW1lc10oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSB3aXRoIFtVVFMtNDYgbm9ybWFsaXphdGlvbl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYpIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYG5hbWVoYXNoYC4gWW91IGNhbiB1c2UgdGhlIGJ1aWx0LWluIHtAbGluayBveCNFbnMuKG5vcm1hbGl6ZTpmdW5jdGlvbil9IGZ1bmN0aW9uIGZvciB0aGlzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgRW5zIH0gZnJvbSAnb3gnXG4gKiBFbnMubmFtZWhhc2goJ3dldm0uZXRoJylcbiAqIC8vIEBsb2c6ICcweGYyNDY2NTFjMWI5YTZiMTQxZDE5YzI2MDRlOWE1OGY1Njc5NzM4MzM5OTBmODMwZDg4MjUzNGE3NDc4MDEzNTknXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbmFtZSAtIEVOUyBuYW1lLlxuICogQHJldHVybnMgRU5TIG5hbWVoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgVWludDhBcnJheSgzMikuZmlsbCgwKTtcbiAgICBpZiAoIW5hbWUpXG4gICAgICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHJlc3VsdCk7XG4gICAgY29uc3QgbGFiZWxzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIC8vIEl0ZXJhdGUgaW4gcmV2ZXJzZSBvcmRlciBidWlsZGluZyB1cCBoYXNoXG4gICAgZm9yIChsZXQgaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBjb25zdCBoYXNoRnJvbUVuY29kZWRMYWJlbCA9IGludGVybmFsLnVud3JhcExhYmVsaGFzaChsYWJlbHNbaV0pO1xuICAgICAgICBjb25zdCBoYXNoZWQgPSBoYXNoRnJvbUVuY29kZWRMYWJlbFxuICAgICAgICAgICAgPyBCeXRlcy5mcm9tSGV4KGhhc2hGcm9tRW5jb2RlZExhYmVsKVxuICAgICAgICAgICAgOiBIYXNoLmtlY2NhazI1NihCeXRlcy5mcm9tU3RyaW5nKGxhYmVsc1tpXSksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgICAgIHJlc3VsdCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmNvbmNhdChyZXN1bHQsIGhhc2hlZCksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgfVxuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKHJlc3VsdCk7XG59XG5uYW1laGFzaC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogTm9ybWFsaXplcyBFTlMgbmFtZSBhY2NvcmRpbmcgdG8gW0VOU0lQLTE1XShodHRwczovL2dpdGh1Yi5jb20vZW5zZG9tYWlucy9kb2NzL2Jsb2IvOWVkZjk0NDNkZTQzMzNhMGVhN2VjNjU4YTg3MDY3MmQ1ZDE4MGQ1My9lbnMtaW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Vuc2lwLTE1LW5vcm1hbGl6YXRpb24tc3RhbmRhcmQubWQpLlxuICpcbiAqIEZvciBtb3JlIGluZm8gc2VlIFtFTlMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSBvbiBuYW1lIHByb2Nlc3NpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBFbnMgfSBmcm9tICdveCdcbiAqIEVucy5ub3JtYWxpemUoJ3dldm0uZXRoJylcbiAqIC8vIEBsb2c6ICd3ZXZtLmV0aCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBuYW1lIC0gRU5TIG5hbWUuXG4gKiBAcmV0dXJucyBOb3JtYWxpemVkIEVOUyBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUpIHtcbiAgICByZXR1cm4gZW5zX25vcm1hbGl6ZShuYW1lKTtcbn1cbm5vcm1hbGl6ZS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_esm/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFVLEdBQUc7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFBDXFxEb2N1bWVudHNcXERBT1xcQXBwXFxjb21tYXBwXFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxFcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UuZGV0YWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlPy5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLm1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXRhaWxzO1xuICAgICAgICB9KSgpO1xuICAgICAgICBjb25zdCBkb2NzUGF0aCA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZSBpbnN0YW5jZW9mIEJhc2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kb2NzUGF0aCB8fCBvcHRpb25zLmRvY3NQYXRoO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NCYXNlVXJsID0gJ2h0dHBzOi8vb3hsaWIuc2gnO1xuICAgICAgICBjb25zdCBkb2NzID0gYCR7ZG9jc0Jhc2VVcmx9JHtkb2NzUGF0aCA/PyAnJ31gO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gW1xuICAgICAgICAgICAgc2hvcnRNZXNzYWdlIHx8ICdBbiBlcnJvciBvY2N1cnJlZC4nLFxuICAgICAgICAgICAgLi4uKG9wdGlvbnMubWV0YU1lc3NhZ2VzID8gWycnLCAuLi5vcHRpb25zLm1ldGFNZXNzYWdlc10gOiBbXSksXG4gICAgICAgICAgICAuLi4oZGV0YWlscyB8fCBkb2NzUGF0aFxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA/IGBEZXRhaWxzOiAke2RldGFpbHN9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZG9jc1BhdGggPyBgU2VlOiAke2RvY3N9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKTtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgb3B0aW9ucy5jYXVzZSA/IHsgY2F1c2U6IG9wdGlvbnMuY2F1c2UgfSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzUGF0aFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY2F1c2VcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0Jhc2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnNpb25cIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGBveEAke2dldFZlcnNpb24oKX1gXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhdXNlID0gb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5kb2NzID0gZG9jcztcbiAgICAgICAgdGhpcy5kb2NzUGF0aCA9IGRvY3NQYXRoO1xuICAgICAgICB0aGlzLnNob3J0TWVzc2FnZSA9IHNob3J0TWVzc2FnZTtcbiAgICB9XG4gICAgd2Fsayhmbikge1xuICAgICAgICByZXR1cm4gd2Fsayh0aGlzLCBmbik7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmICdjYXVzZScgaW4gZXJyICYmIGVyci5jYXVzZSlcbiAgICAgICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XG4gICAgcmV0dXJuIGZuID8gbnVsbCA6IGVycjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/./node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/* v8 ignore next */\nkeccak256.parseError = (error) => error;\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/* v8 ignore next */\nripemd160.parseError = (error) => error;\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/* v8 ignore next */\nsha256.parseError = (error) => error;\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n/* v8 ignore next */\nvalidate.parseError = (error) => error;\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hhc2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ0o7QUFDTDtBQUMxQjtBQUNKO0FBQ2hDO0FBQ0EsOEVBQThFLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCLElBQUksa0JBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLG1EQUFtRDtBQUMvRCxrQkFBa0IsOERBQWUsQ0FBQywyQ0FBVTtBQUM1QztBQUNBO0FBQ0EsV0FBVyw4Q0FBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLGtFQUFlLENBQUMsMkNBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsc0JBQXNCLElBQUksa0JBQWtCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksbURBQW1EO0FBQy9ELGtCQUFrQiw0REFBWSxDQUFDLDJDQUFVO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWSxXQUFXLHlDQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFBDXFxEb2N1bWVudHNcXERBT1xcQXBwXFxjb21tYXBwXFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxIYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IGFzIG5vYmxlX2tlY2NhazI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgYXMgbm9ibGVfc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbS2VjY2FrMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMykgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYGtlY2Nha18yNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ2FsY3VsYXRlIEhhc2ggb2YgYSBTdHJpbmdcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmUgUmV0dXJuIFR5cGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJywgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBLZWNjYWsyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9rZWNjYWsyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5rZWNjYWsyNTYucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtSaXBlbWQxNjBdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JJUEVNRCkgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYHJpcGVtZDE2MGAgZnJvbSBbYEBub2JsZS9oYXNoZXNgXShodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLWhhc2hlcyksIGFuIGF1ZGl0ZWQgJiBtaW5pbWFsIEpTIGhhc2hpbmcgbGlicmFyeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhhc2ggfSBmcm9tICdveCdcbiAqXG4gKiBIYXNoLnJpcGVtZDE2MCgnMHhkZWFkYmVlZicpXG4gKiAvLyAnMHgyMjY4MjFjMmY1NDIzZTExZmU5YWY2OGJkMjg1YzI0OWRiMmU0YjVhJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBSaXBlbWQxNjAgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJpcGVtZDE2MCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9yaXBlbWQxNjAoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5yaXBlbWQxNjAucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIFtTaGEyNTZdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NIQS0yNTYpIGhhc2ggb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGEgcmUtZXhwb3J0IG9mIGBzaGEyNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5zaGEyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gJzB4NWY3OGMzMzI3NGU0M2ZhOWRlNTY1OTI2NWMxZDkxN2UyNWMwMzcyMmRjYjBiOGQyN2RiOGQ1ZmVhYTgxMzk1MydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgU2hhMjU2IGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGEyNTYodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gbm9ibGVfc2hhMjU2KEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuc2hhMjU2LnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoYXNoIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnZhbGlkYXRlLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/./node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/* v8 ignore next */\nassert.parseError = (error) => error;\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/* v8 ignore next */\nconcat.parseError = (error) => error;\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/* v8 ignore next */\nfrom.parseError = (error) => error;\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x0${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\nfromBoolean.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/* v8 ignore next */\nfromBytes.parseError = (error) => error;\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue.length % 2 === 0 ? stringValue : `0${stringValue}`}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\nfromNumber.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\nfromString.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/* v8 ignore next */\nisEqual.parseError = (error) => error;\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/* v8 ignore next */\npadLeft.parseError = (error) => error;\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/* v8 ignore next */\npadRight.parseError = (error) => error;\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/* v8 ignore next */\nrandom.parseError = (error) => error;\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/* v8 ignore next */\nslice.parseError = (error) => error;\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/* v8 ignore next */\nsize.parseError = (error) => error;\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/* v8 ignore next */\ntrimLeft.parseError = (error) => error;\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/* v8 ignore next */\ntrimRight.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/* v8 ignore next */\ntoBigInt.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    let hex_ = hex;\n    if (options.size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        hex_ = trimLeft(hex_);\n    }\n    if (trimLeft(hex_) === '0x00')\n        return false;\n    if (trimLeft(hex_) === '0x01')\n        return true;\n    throw new InvalidHexBooleanError(hex_);\n}\n/* v8 ignore next */\ntoBoolean.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/* v8 ignore next */\ntoBytes.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/* v8 ignore next */\ntoNumber.parseError = (error) => error;\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/* v8 ignore next */\ntoString.parseError = (error) => error;\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/* v8 ignore next */\nvalidate.parseError = (error) => error;\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUN0QjtBQUNFO0FBQ0o7QUFDb0I7QUFDUjtBQUM5QztBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0Esa0NBQWtDLGlCQUFpQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUNBQW1DO0FBQzFDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQyw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ087QUFDUCxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQiw0QkFBNEIsc0JBQXNCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3Qyx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcUENcXERvY3VtZW50c1xcREFPXFxBcHBcXGNvbW1hcHBcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEhleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9ieXRlcyBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSAvKiNfX1BVUkVfXyovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkSGV4VmFsdWVUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiAvLyBAZXJyb3I6IEhleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4XFwke3N0cmluZ31cImAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKCEvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuYXNzZXJ0LnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBDb25jYXRlbmF0ZXMgdHdvIG9yIG1vcmUge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmNvbmNhdCgnMHgxMjMnLCAnMHg0NTYnKVxuICogLy8gQGxvZzogJzB4MTIzNDU2J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIHRvIGNvbmNhdGVuYXRlLlxuICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoLi4udmFsdWVzKSB7XG4gICAgcmV0dXJuIGAweCR7dmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MgKyB4LnJlcGxhY2UoJzB4JywgJycpLCAnJyl9YDtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5jb25jYXQucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBmcm9tIGEgaGV4IHN0cmluZyBvciB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEhleC5mcm9tQm9vbGVhbmBcbiAqXG4gKiAtIGBIZXguZnJvbVN0cmluZ2BcbiAqXG4gKiAtIGBIZXguZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbSgnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICpcbiAqIEhleC5mcm9tKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5mcm9tLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBFbmNvZGVzIGEgYm9vbGVhbiBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiAnMHgxJ1xuICpcbiAqIEhleC5mcm9tQm9vbGVhbihmYWxzZSlcbiAqIC8vIEBsb2c6ICcweDAnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKHRydWUsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYm9vbGVhbiB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQm9vbGVhbih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaGV4ID0gYDB4MCR7TnVtYmVyKHZhbHVlKX1gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuZnJvbUJvb2xlYW4ucGFyc2VFcnJvciA9IChlcnJvcikgPT4gXG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZXJyb3I7XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21CeXRlcyhCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0cmluZyArPSBoZXhlc1t2YWx1ZVtpXV07XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmd9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xuZnJvbUJ5dGVzLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIG9yIGJpZ2ludCBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogJzB4MWE0J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMCwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBudW1iZXIgb3IgYmlnaW50IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlXyA9IEJpZ0ludCh2YWx1ZSk7XG4gICAgbGV0IG1heFZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGlmIChzaWduZWQpXG4gICAgICAgICAgICBtYXhWYWx1ZSA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4gLSAxbikpIC0gMW47XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heFZhbHVlID0gMm4gKiogKEJpZ0ludChzaXplKSAqIDhuKSAtIDFuO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG1heFZhbHVlID0gQmlnSW50KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKTtcbiAgICB9XG4gICAgY29uc3QgbWluVmFsdWUgPSB0eXBlb2YgbWF4VmFsdWUgPT09ICdiaWdpbnQnICYmIHNpZ25lZCA/IC1tYXhWYWx1ZSAtIDFuIDogMDtcbiAgICBpZiAoKG1heFZhbHVlICYmIHZhbHVlXyA+IG1heFZhbHVlKSB8fCB2YWx1ZV8gPCBtaW5WYWx1ZSkge1xuICAgICAgICBjb25zdCBzdWZmaXggPSB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnID8gJ24nIDogJyc7XG4gICAgICAgIHRocm93IG5ldyBJbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgIG1heDogbWF4VmFsdWUgPyBgJHttYXhWYWx1ZX0ke3N1ZmZpeH1gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWluOiBgJHttaW5WYWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIHZhbHVlOiBgJHt2YWx1ZX0ke3N1ZmZpeH1gLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSAoc2lnbmVkICYmIHZhbHVlXyA8IDAgPyAoMW4gPDwgQmlnSW50KHNpemUgKiA4KSkgKyBCaWdJbnQodmFsdWVfKSA6IHZhbHVlXykudG9TdHJpbmcoMTYpO1xuICAgIGNvbnN0IGhleCA9IGAweCR7c3RyaW5nVmFsdWUubGVuZ3RoICUgMiA9PT0gMCA/IHN0cmluZ1ZhbHVlIDogYDAke3N0cmluZ1ZhbHVlfWB9YDtcbiAgICBpZiAoc2l6ZSlcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoaGV4LCBzaXplKTtcbiAgICByZXR1cm4gaGV4O1xufVxuZnJvbU51bWJlci5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyLmVuY29kZSh2YWx1ZSksIG9wdGlvbnMpO1xufVxuZnJvbVN0cmluZy5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5pc0VxdWFsKCcweGRlYWRiZWVmJywgJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC5pc0VxdWFsKCcweGRhJywgJzB4YmEnKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXhBIC0gVGhlIGZpcnN0IHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBoZXhCIC0gVGhlIHNlY29uZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWVzIGFyZSBlcXVhbCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsKGhleEEsIGhleEIpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5pc0VxdWFsLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MDAwMDEyMzQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKiB2OCBpZ25vcmUgbmV4dCAqL1xucGFkTGVmdC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogUGFkcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0aGUgcmlnaHQgd2l0aCB6ZXJvIGJ5dGVzIHVudGlsIGl0IHJlYWNoZXMgdGhlIGdpdmVuIGBzaXplYCAoZGVmYXVsdDogMzIgYnl0ZXMpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnBhZFJpZ2h0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MTIzNDAwMDAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5wYWRSaWdodC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGhleCA9IEhleC5yYW5kb20oMzIpXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBSYW5kb20ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoQnl0ZXMucmFuZG9tKGxlbmd0aCkpO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnJhbmRvbS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgMSwgNClcbiAqIC8vIEBsb2c6ICcweDIzNDU2NydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gc2xpY2UuXG4gKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzbGljZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZVxuICAgICAgICAucmVwbGFjZSgnMHgnLCAnJylcbiAgICAgICAgLnNsaWNlKChzdGFydCA/PyAwKSAqIDIsIChlbmQgPz8gdmFsdWUubGVuZ3RoKSAqIDIpfWA7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5zbGljZS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2l6ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnNpemUucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50cmltTGVmdCgnMHgwMDAwMDAwMGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6ICcweGRlYWRiZWVmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byB0cmltLlxuICogQHJldHVybnMgVGhlIHRyaW1tZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50cmltTGVmdC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogVHJpbXMgdHJhaWxpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50cmltUmlnaHQoJzB4ZGVhZGJlZWYwMDAwMDAwMCcpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50cmltUmlnaHQucGFyc2VFcnJvciA9IChlcnJvcikgPT4gZXJyb3I7XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIEJpZ0ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0JpZ0ludCgnMHgxYTQnKVxuICogLy8gQGxvZzogNDIwblxuICpcbiAqIEhleC50b0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgQmlnSW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50b0JpZ0ludC5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgaGV4XyA9IGhleDtcbiAgICBpZiAob3B0aW9ucy5zaXplKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgICAgICBoZXhfID0gdHJpbUxlZnQoaGV4Xyk7XG4gICAgfVxuICAgIGlmICh0cmltTGVmdChoZXhfKSA9PT0gJzB4MDAnKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRyaW1MZWZ0KGhleF8pID09PSAnMHgwMScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleF8pO1xufVxuLyogdjggaWdub3JlIG5leHQgKi9cbnRvQm9vbGVhbi5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBIZXgudG9CeXRlcygnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50b0J5dGVzLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IGVycm9yO1xuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MWE0JylcbiAqIC8vIEBsb2c6IDQyMFxuICpcbiAqIEhleC50b051bWJlcignMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBudW1iZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b051bWJlcihoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkLCBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICghc2lnbmVkICYmICFzaXplKVxuICAgICAgICByZXR1cm4gTnVtYmVyKGhleCk7XG4gICAgcmV0dXJuIE51bWJlcih0b0JpZ0ludChoZXgsIG9wdGlvbnMpKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50b051bWJlci5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvU3RyaW5nKCcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMScpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQhJ1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywge1xuICogIHNpemU6IDMyLFxuICogfSlcbiAqIC8vIEBsb2c6ICdIZWxsbyB3b3JsZCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlcyA9IEJ5dGVzLmZyb21IZXgoaGV4KTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpbnRlcm5hbF9ieXRlcy5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgYnl0ZXMgPSBCeXRlcy50cmltUmlnaHQoYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG50b1N0cmluZy5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqXG4gKiBIZXgudmFsaWRhdGUoQnl0ZXMuZnJvbShbMSwgMiwgM10pKVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWUgaXMgYSB7QGxpbmsgb3gjSGV4LkhleH0sIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qIHY4IGlnbm9yZSBuZXh0ICovXG52YWxpZGF0ZS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBlcnJvcjtcbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGludGVnZXIgaXMgb3V0IG9mIHJhbmdlLCBhbmQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzIGEgaGV4IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb21OdW1iZXIoNDIwMTgyNzM4OTEyNzMxMjgzNzEyOTM3MTI5KVxuICogLy8gQGVycm9yOiBIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcjogTnVtYmVyIFxcYDQuMjAxODI3Mzg5MTI3MzEyNmUrMjZcXGAgaXMgbm90IGluIHNhZmUgdW5zaWduZWQgaW50ZWdlciByYW5nZSAoYDBgIHRvIGA5MDA3MTk5MjU0NzQwOTkxYClcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW50ZWdlck91dE9mUmFuZ2VFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWF4LCBtaW4sIHNpZ25lZCwgc2l6ZSwgdmFsdWUsIH0pIHtcbiAgICAgICAgc3VwZXIoYE51bWJlciBcXGAke3ZhbHVlfVxcYCBpcyBub3QgaW4gc2FmZSR7c2l6ZSA/IGAgJHtzaXplICogOH0tYml0YCA6ICcnfSR7c2lnbmVkID8gJyBzaWduZWQnIDogJyB1bnNpZ25lZCd9IGludGVnZXIgcmFuZ2UgJHttYXggPyBgKFxcYCR7bWlufVxcYCB0byBcXGAke21heH1cXGApYCA6IGAoYWJvdmUgXFxgJHttaW59XFxgKWB9YCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgcHJvdmlkZWQgaGV4IHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudG9Cb29sZWFuKCcweGEnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcjogSGV4IHZhbHVlIGBcIjB4YVwiYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLlxuICogLy8gQGVycm9yOiBUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleEJvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhleCkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHtoZXh9XCJcXGAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIHZhbHVlIGlzIG5vdCBhIHZhbGlkIGhleCB0eXBlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmFzc2VydCgxKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFR5cGVFcnJvcjogVmFsdWUgYDFgIG9mIHR5cGUgYG51bWJlcmAgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFR5cGVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3R5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyBKc29uLnN0cmluZ2lmeSh2YWx1ZSkgOiB2YWx1ZX1cXGAgb2YgdHlwZSBcXGAke3R5cGVvZiB2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdHlwZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnSGV4IHR5cGVzIG11c3QgYmUgcmVwcmVzZW50ZWQgYXMgYFwiMHgke3N0cmluZ31cImAuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmFzc2VydCgnMHgwMTIzNDU2Nzg5YWJjZGVmZycpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkSGV4VmFsdWVFcnJvcjogVmFsdWUgYDB4MDEyMzQ1Njc4OWFiY2RlZmdgIGlzIGFuIGludmFsaWQgaGV4IHZhbHVlLlxuICogLy8gQGVycm9yOiBIZXggdmFsdWVzIG11c3Qgc3RhcnQgd2l0aCBgXCIweFwiYCBhbmQgY29udGFpbiBvbmx5IGhleGFkZWNpbWFsIGNoYXJhY3RlcnMgKDAtOSwgYS1mLCBBLUYpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkSGV4VmFsdWVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleFZhbHVlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBpcyBhbiBvZGQgbGVuZ3RoLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tSGV4KCcweGFiY2RlJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRMZW5ndGhFcnJvcjogSGV4IHZhbHVlIGBcIjB4YWJjZGVcImAgaXMgYW4gb2RkIGxlbmd0aCAoNSBuaWJibGVzKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZExlbmd0aEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7dmFsdWV9XCJcXGAgaXMgYW4gb2RkIGxlbmd0aCAoJHt2YWx1ZS5sZW5ndGggLSAyfSBuaWJibGVzKS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFsnSXQgbXVzdCBiZSBhbiBldmVuIGxlbmd0aC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZExlbmd0aEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBleHBlY3RlZCBtYXggc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVPdmVyZmxvd0Vycm9yOiBTaXplIGNhbm5vdCBleGNlZWQgYDhgIGJ5dGVzLiBHaXZlbiBzaXplOiBgMTJgIGJ5dGVzLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplT3ZlcmZsb3dFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZ2l2ZW5TaXplLCBtYXhTaXplIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgY2Fubm90IGV4Y2VlZCBcXGAke21heFNpemV9XFxgIGJ5dGVzLiBHaXZlbiBzaXplOiBcXGAke2dpdmVuU2l6ZX1cXGAgYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZU92ZXJmbG93RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNsaWNlIG9mZnNldCBleGNlZWRzIHRoZSBib3VuZHMgb2YgdGhlIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnNsaWNlKCcweDAxMjM0NTY3ODknLCA2KVxuICogLy8gQGVycm9yOiBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDZgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGA1YCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgdGhlIHZhbHVlIGV4Y2VlZHMgdGhlIHBhZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnBhZExlZnQoJzB4MWE0ZTEyYTQ1YTIxMzIzMTIzYWFhODdhODk3YTg5N2E4OThhNjU2N2E1NzhhODY3YTk4Nzc4YTY2N2E4NWE4NzVhODdhNmE3ODdhNjVhNjc1YTZhOScsIDMyKVxuICogLy8gQGVycm9yOiBIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yOiBIZXggc2l6ZSAoYDQzYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKGAzMmApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_esm/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = /*#__PURE__*/ '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\nparse.parseError = (error) => \n/* v8 ignore next */\nerror;\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\nstringify.parseError = (error) => \n/* v8 ignore next */\nerror;\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0pzb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSw2QkFBNkIsZ0ZBQWdGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixjQUFjLGdGQUFnRjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFLQUFxSztBQUNySztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcSnNvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiaWdJbnRTdWZmaXggPSAvKiNfX1BVUkVfXyovICcjX19iaWdpbnQnO1xuLyoqXG4gKiBQYXJzZXMgYSBKU09OIHN0cmluZywgd2l0aCBzdXBwb3J0IGZvciBgYmlnaW50YC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEpzb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBqc29uID0gSnNvbi5wYXJzZSgne1wiZm9vXCI6XCJiYXJcIixcImJhelwiOlwiNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjAjX19iaWdpbnRcIn0nKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBmb286ICdiYXInLFxuICogLy8gQGxvZzogICBiYXo6IDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cmluZyAtIFRoZSB2YWx1ZSB0byBwYXJzZS5cbiAqIEBwYXJhbSByZXZpdmVyIC0gQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdHMuXG4gKiBAcmV0dXJucyBUaGUgcGFyc2VkIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2Uoc3RyaW5nLCByZXZpdmVyKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyaW5nLCAoa2V5LCB2YWx1ZV8pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZV87XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKGJpZ0ludFN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlLnNsaWNlKDAsIC1iaWdJbnRTdWZmaXgubGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IHJldml2ZXIoa2V5LCB2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbn1cbnBhcnNlLnBhcnNlRXJyb3IgPSAoZXJyb3IpID0+IFxuLyogdjggaWdub3JlIG5leHQgKi9cbmVycm9yO1xuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHZhbHVlIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnN0cmluZ2lmeSh7XG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuLFxuICogfSlcbiAqIC8vIEBsb2c6ICd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnkuXG4gKiBAcGFyYW0gcmVwbGFjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy4gSXQgaXMgcGFzc2VkIHRoZSBrZXkgYW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgYW5kIG11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBKU09OIHN0cmluZy4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGUgcHJvcGVydHkgaXMgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKiBAcGFyYW0gc3BhY2UgLSBBIHN0cmluZyBvciBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgSlNPTiBzdHJpbmcuIElmIGl0IGlzIGEgbnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gdXNlIGFzIGluZGVudGF0aW9uOyBpZiBpdCBpcyBhIHN0cmluZyAoZS5nLiBgJ1xcdCdgKSwgaXQgdXNlcyB0aGUgc3RyaW5nIGFzIHRoZSBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUaGUgSlNPTiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbnN0cmluZ2lmeS5wYXJzZUVycm9yID0gKGVycm9yKSA9PiBcbi8qIHY4IGlnbm9yZSBuZXh0ICovXG5lcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2J5dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ3JDO0FBQ087QUFDUCxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQix3REFBdUI7QUFDekMsdUJBQXVCLDJDQUFVO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCwyQ0FBVTtBQUNwRSxrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLDJDQUFVO0FBQ2xCLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQ0FBZ0M7QUFDdkMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQztBQUN4QyxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXFBDXFxEb2N1bWVudHNcXERBT1xcQXBwXFxjb21tYXBwXFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxpbnRlcm5hbFxcYnl0ZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi4vQnl0ZXMuanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEJ5dGVzLnNpemUodmFsdWUpIC0gMSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgQnl0ZXMuc2l6ZSh2YWx1ZSkgIT09IGVuZCAtIHN0YXJ0KSB7XG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBCeXRlcy5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IGNoYXJDb2RlTWFwID0ge1xuICAgIHplcm86IDQ4LFxuICAgIG5pbmU6IDU3LFxuICAgIEE6IDY1LFxuICAgIEY6IDcwLFxuICAgIGE6IDk3LFxuICAgIGY6IDEwMixcbn07XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gY2hhckNvZGVUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLm5pbmUpXG4gICAgICAgIHJldHVybiBjaGFyIC0gY2hhckNvZGVNYXAuemVybztcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBjaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gY2hhckNvZGVNYXAuZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoY2hhckNvZGVNYXAuYSAtIDEwKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWU7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/ens.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/ens.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packetToBytes: () => (/* binding */ packetToBytes),\n/* harmony export */   unwrapLabelhash: () => (/* binding */ unwrapLabelhash),\n/* harmony export */   wrapLabelhash: () => (/* binding */ wrapLabelhash)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"(ssr)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Ens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Ens.js */ \"(ssr)/./node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nfunction packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, '');\n    if (value.length === 0)\n        return new Uint8Array(1);\n    const bytes = new Uint8Array(_index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split('.');\n    for (let i = 0; i < list.length; i++) {\n        let encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255)\n            encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(wrapLabelhash(_Ens_js__WEBPACK_IMPORTED_MODULE_1__.labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1)\n        return bytes.slice(0, offset + 1);\n    return bytes;\n}\n/** @internal */\nfunction wrapLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n/** @internal */\nfunction unwrapLabelhash(label) {\n    if (label.length !== 66)\n        return null;\n    if (label.indexOf('[') !== 0)\n        return null;\n    if (label.indexOf(']') !== 65)\n        return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!_Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(hash, { strict: true }))\n        return null;\n    return hash;\n}\n//# sourceMappingURL=ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBdUM7QUFDTjtBQUNBO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpREFBZ0I7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsc0JBQXNCLGlEQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaURBQWdCLGVBQWUsOENBQWE7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QyxTQUFTLDZDQUFZLFNBQVMsY0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcaW50ZXJuYWxcXGVucy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCeXRlcyB9IGZyb20gJy4uLy4uL2luZGV4LmpzJztcbmltcG9ydCAqIGFzIEVucyBmcm9tICcuLi9FbnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG4vKipcbiAqIEBpbnRlcm5hbFxuICogRW5jb2RlcyBhIFtETlMgcGFja2V0XShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvcmVzb2x1dGlvbi9uYW1lcyNkbnMpIGludG8gYSBCeXRlQXJyYXkgY29udGFpbmluZyBhIFVEUCBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFja2V0VG9CeXRlcyhwYWNrZXQpIHtcbiAgICAvLyBzdHJpcCBsZWFkaW5nIGFuZCB0cmFpbGluZyBgLmBcbiAgICBjb25zdCB2YWx1ZSA9IHBhY2tldC5yZXBsYWNlKC9eXFwufFxcLiQvZ20sICcnKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShCeXRlcy5mcm9tU3RyaW5nKHZhbHVlKS5ieXRlTGVuZ3RoICsgMik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgY29uc3QgbGlzdCA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyhsaXN0W2ldKTtcbiAgICAgICAgLy8gaWYgdGhlIGxlbmd0aCBpcyA+IDI1NSwgbWFrZSB0aGUgZW5jb2RlZCBsYWJlbCB2YWx1ZSBhIGxhYmVsaGFzaFxuICAgICAgICAvLyB0aGlzIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgdW5pdmVyc2FsIHJlc29sdmVyXG4gICAgICAgIGlmIChlbmNvZGVkLmJ5dGVMZW5ndGggPiAyNTUpXG4gICAgICAgICAgICBlbmNvZGVkID0gQnl0ZXMuZnJvbVN0cmluZyh3cmFwTGFiZWxoYXNoKEVucy5sYWJlbGhhc2gobGlzdFtpXSkpKTtcbiAgICAgICAgYnl0ZXNbb2Zmc2V0XSA9IGVuY29kZWQubGVuZ3RoO1xuICAgICAgICBieXRlcy5zZXQoZW5jb2RlZCwgb2Zmc2V0ICsgMSk7XG4gICAgICAgIG9mZnNldCArPSBlbmNvZGVkLmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSBvZmZzZXQgKyAxKVxuICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgb2Zmc2V0ICsgMSk7XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdyYXBMYWJlbGhhc2goaGFzaCkge1xuICAgIHJldHVybiBgWyR7aGFzaC5zbGljZSgyKX1dYDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBMYWJlbGhhc2gobGFiZWwpIHtcbiAgICBpZiAobGFiZWwubGVuZ3RoICE9PSA2NilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ1snKSAhPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGxhYmVsLmluZGV4T2YoJ10nKSAhPT0gNjUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGhhc2ggPSBgMHgke2xhYmVsLnNsaWNlKDEsIDY1KX1gO1xuICAgIGlmICghSGV4LnZhbGlkYXRlKGhhc2gsIHsgc3RyaWN0OiB0cnVlIH0pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gaGFzaDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVucy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/ens.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/./node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ3hDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsZ0RBQU87QUFDbEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUcsSUFBSSwyQkFBMkIsRUFBRSxNQUFNO0FBQzlFO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcaW50ZXJuYWxcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbi5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXJsKHVybCkge1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICByZXR1cm4gdmVyc2lvbjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dHlQcmludChhcmdzKSB7XG4gICAgaWYgKCFhcmdzKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGFyZ3MpXG4gICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IGVudHJpZXMucmVkdWNlKChhY2MsIFtrZXldKSA9PiBNYXRoLm1heChhY2MsIGtleS5sZW5ndGgpLCAwKTtcbiAgICByZXR1cm4gZW50cmllc1xuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAgICR7YCR7a2V5fTpgLnBhZEVuZChtYXhMZW5ndGggKyAxKX0gICR7dmFsdWV9YClcbiAgICAgICAgLmpvaW4oJ1xcbicpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_esm/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/./node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data.length === 1 && dir === 'right')\n        data = `${data}0`;\n    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL2ludGVybmFsL2hleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBaUM7QUFDakM7QUFDTztBQUNQLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLHNEQUFxQjtBQUN2Qyx1QkFBdUIseUNBQVE7QUFDL0I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1AsMERBQTBELHlDQUFRO0FBQ2xFLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEseUNBQVE7QUFDaEIsa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0Esa0JBQWtCLHlDQUFRO0FBQzFCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTywrQkFBK0I7QUFDdEMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEtBQUs7QUFDdkIsZ0JBQWdCLDRCQUE0QixLQUFLLFNBQVM7QUFDMUQ7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcaW50ZXJuYWxcXGhleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIZXggZnJvbSAnLi4vSGV4LmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTaXplKGhleCwgc2l6ZV8pIHtcbiAgICBpZiAoSGV4LnNpemUoaGV4KSA+IHNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVPdmVyZmxvd0Vycm9yKHtcbiAgICAgICAgICAgIGdpdmVuU2l6ZTogSGV4LnNpemUoaGV4KSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemVfLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBIZXguc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEhleC5zaXplKHZhbHVlKSAhPT0gZW5kIC0gc3RhcnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBlbmQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2VuZCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoaGV4Xywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGhleF87XG4gICAgY29uc3QgaGV4ID0gaGV4Xy5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBpZiAoaGV4Lmxlbmd0aCA+IHNpemUgKiAyKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICAgICAgICBzaXplOiBNYXRoLmNlaWwoaGV4Lmxlbmd0aCAvIDIpLFxuICAgICAgICAgICAgdGFyZ2V0U2l6ZTogc2l6ZSxcbiAgICAgICAgICAgIHR5cGU6ICdIZXgnLFxuICAgICAgICB9KTtcbiAgICByZXR1cm4gYDB4JHtoZXhbZGlyID09PSAncmlnaHQnID8gJ3BhZEVuZCcgOiAncGFkU3RhcnQnXShzaXplICogMiwgJzAnKX1gO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWUucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGlyID09PSAncmlnaHQnKVxuICAgICAgICBkYXRhID0gYCR7ZGF0YX0wYDtcbiAgICByZXR1cm4gYDB4JHtkYXRhLmxlbmd0aCAlIDIgPT09IDEgPyBgMCR7ZGF0YX1gIDogZGF0YX1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ox/_esm/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_esm/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxQQ1xcRG9jdW1lbnRzXFxEQU9cXEFwcFxcY29tbWFwcFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcdmVyc2lvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9ICcwLjEuMSc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ox/_esm/core/version.js\n");

/***/ })

};
;